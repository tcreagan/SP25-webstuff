import { ActionType, EditorAction, EditorState } from "../EditorReducer";
import { sectionFromId, deepCloneNode, findParentNode } from "../Helpers";
import Widget from "components/pages/app/widgets/Widget";
import vertical from "widgetFiles/addColumn.json";
import navChild from "widgetFiles/addNav.json";
import { NodeAttribute } from "types/HtmlNodes";

export function handleAddAction(state: EditorState, action: EditorAction): EditorState {
    if (action.type !== ActionType.ADD_ELEMENT) {
      return state;
    }
  
    const { elementId } = action;
    const section = sectionFromId(elementId);
    const parentIndex = parseInt(elementId.split("-")[1]);
  
    // Retrieve the node list for easier handling
    const nodesCopy = [...state[section].html.nodes];
    const parentNode = nodesCopy[parentIndex];
  
    //Double-checks there is a parent node and a child array
    if (!parentNode) {
      console.error("Parent node not found.");
      return state;
    }
    if (!Array.isArray(parentNode.children)) {
      parentNode.children = [];
    }
  
    // Safely retrieve the className
    const className = parentNode.attributes?.["className"]?.value;
    if (!className) {
      console.error("Parent node has no className attribute.");
      return state;
    }
  
    //Pull the correct template for new nodes
    let templateNode = undefined;
    if (className === "horizontal"){
        templateNode = vertical.html.nodes[0];
    }
    else if (className === "navigation"){
        templateNode = navChild.html.nodes[0];
    }
    else{
        return state;
    }

    //Corrects issues where template could not apply correctly by verifying attributes, styles, and childDirection. 
    //Code generated by ChatGPT until line 78
    const processedAttributes: Record<string, NodeAttribute> = {};
    if (templateNode.attributes) {
        for (const [key, value] of Object.entries(templateNode.attributes)) {
            if (typeof value === "object" && value !== null && "value" in value) {
                processedAttributes[key] = value as NodeAttribute;
            } 
            else{
                processedAttributes[key] = { value: String(value) ?? "", input: { type: "text", displayName: key } };
            }
        }
    }
    const processedStyle: Record<string, NodeAttribute> = {};
    if (templateNode.style) {
                for (const [key, value] of Object.entries(templateNode.style)) {
            if (typeof value === "object" && value !== null && "value" in value) {
                processedStyle[key] = {
                    value: value.value ?? "",
                    input: value.input ?? { type: "text", displayName: key }
                };
            } else {
                processedStyle[key] = { value: "", input: { type: "text", displayName: key } };
            }
        }
    }
    const childDirection = "childDirection" in templateNode.metadata
        ? templateNode.metadata.childDirection as "horizontal" | "vertical"
        : "horizontal"; // Default to horizontal
    

    // Creates a new node from the template
    const newChildNode = {
        id: nodesCopy.length, // Assign a unique ID
        element: templateNode.element ?? "div", // Default to "div"
        attributes: processedAttributes, // Processed attributes
        style: processedStyle, // Processed style
        children: [],
        metadata: {
            ...templateNode.metadata,
            childDirection: childDirection // Checks for existing childDirection
        }
    };
  
    // Add the new node to the nodes array
    nodesCopy.push(newChildNode);
    const newChildIndex = nodesCopy.length - 1;
  
    // Append the new child node's index to the parent's children array
    parentNode.children.push(newChildIndex);
  
    // Update the state with the new nodes array
    return {
        ...state,
        [section]: {
            ...state[section],
            html: {
                ...state[section].html,
                nodes: nodesCopy,
            }
        }
    };
}
